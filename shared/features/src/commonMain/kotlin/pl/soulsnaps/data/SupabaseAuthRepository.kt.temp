package pl.soulsnaps.data

import io.github.jan.supabase.gotrue.auth
import io.github.jan.supabase.gotrue.providers.builtin.Email
import pl.soulsnaps.domain.AuthRepository
import pl.soulsnaps.domain.model.UserSession
import pl.soulsnaps.network.SupabaseClient

class SupabaseAuthRepository : AuthRepository {
    
    private val auth = SupabaseClient.getAuth()
    
    override suspend fun signIn(email: String, password: String): UserSession {
        return try {
            val result = auth.signInWith(Email) {
                this.email = email
                this.password = password
            }
            
            when (result) {
                is io.github.jan.supabase.gotrue.providers.builtin.EmailSignInResult.Success -> {
                    val session = result.session
                    val user = session.user
                    UserSession(
                        userId = user.id,
                        email = user.email ?: "",
                        isAnonymous = false,
                        displayName = user.userMetadata?.get("full_name") as? String ?: "",
                        createdAt = user.createdAt,
                        lastActiveAt = user.lastSignInAt
                    )
                }
                is io.github.jan.supabase.gotrue.providers.builtin.EmailSignInResult.Error -> {
                    throw Exception(result.message)
                }
            }
        } catch (e: Exception) {
            throw e
        }
    }
    
    override suspend fun register(email: String, password: String): UserSession {
        return try {
            val result = auth.signUpWith(Email) {
                this.email = email
                this.password = password
            }
            
            when (result) {
                is io.github.jan.supabase.gotrue.providers.builtin.EmailSignUpResult.Success -> {
                    val session = result.session
                    val user = session?.user
                    if (user != null) {
                        UserSession(
                            userId = user.id,
                            email = user.email ?: "",
                            isAnonymous = false,
                            displayName = user.userMetadata?.get("full_name") as? String ?: "",
                            createdAt = user.createdAt,
                            lastActiveAt = user.lastSignInAt
                        )
                    } else {
                        throw Exception("Email confirmation required")
                    }
                }
                is io.github.jan.supabase.gotrue.providers.builtin.EmailSignUpResult.Error -> {
                    throw Exception(result.message)
                }
            }
        } catch (e: Exception) {
            throw e
        }
    }
    
    override suspend fun signInAnonymously(): UserSession {
        return try {
            val session = auth.signUpAnonymously()
            val user = session.user
            
            UserSession(
                userId = user.id,
                email = "",
                isAnonymous = true,
                displayName = "Anonymous User",
                createdAt = user.createdAt,
                lastActiveAt = user.lastSignInAt
            )
        } catch (e: Exception) {
            throw e
        }
    }
    
    override fun signOut() {
        try {
            auth.signOut()
        } catch (e: Exception) {
            throw e
        }
    }
    
    override fun currentUser(): UserSession? {
        return try {
            val session = auth.currentSessionOrNull()
            val user = session?.user
            
            user?.let {
                UserSession(
                    userId = it.id,
                    email = it.email ?: "",
                    isAnonymous = it.appMetadata?.get("provider") == "anonymous",
                    displayName = it.userMetadata?.get("full_name") as? String ?: "",
                    createdAt = it.createdAt,
                    lastActiveAt = it.lastSignInAt
                )
            }
        } catch (e: Exception) {
            null
        }
    }
    

}
